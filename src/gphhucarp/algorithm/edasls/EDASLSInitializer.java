package gphhucarp.algorithm.edasls;

import ec.*;
import ec.simple.SimpleInitializer;
import gphhucarp.core.Instance;
import gphhucarp.core.InstanceSamples;
import gphhucarp.decisionprocess.PoolFilter;
import gphhucarp.decisionprocess.RoutingPolicy;
import gphhucarp.decisionprocess.TieBreaker;
import gphhucarp.decisionprocess.poolfilter.ActFeasiblePoolFilter;
import gphhucarp.decisionprocess.poolfilter.ExpFeasiblePoolFilter;
import gphhucarp.decisionprocess.routingpolicy.*;
import gphhucarp.decisionprocess.tiebreaker.RandomTieBreaker;
import org.apache.commons.math3.random.RandomDataGenerator;

import java.util.List;

/**
 * The initializer used by EDASLS.
 * The first 5 individuals are generated by Path Scanning.
 * The remaining popsize-5 individuals are generated by Best Insertion Heuristic.
 * No duplication is allowed.
 */

public class EDASLSInitializer extends SimpleInitializer {

    @Override
    public Population initialPopulation(final EvolutionState state, int thread) {
        Population p = setupPopulation(state, thread);

        // initialise a random tie breaker
        EDASLSEvolutionState edaslsState = (EDASLSEvolutionState)state;
        RandomDataGenerator rdg = edaslsState.getRdg();
        PoolFilter poolFilter = new ExpFeasiblePoolFilter();
        TieBreaker tieBreaker = new RandomTieBreaker(rdg);

        // get the instances
        EDASLSProblem problem = (EDASLSProblem)state.evaluator.p_problem;
        InstanceSamples iSamples = problem.getEvaluationModel().getInstanceSamples().get(0);

        Subpopulation subpop = p.subpops[0];
        GiantTaskSequenceSpecies species = (GiantTaskSequenceSpecies)subpop.species;

        // initialise the first 5 individuals by path scanning
        RoutingPolicy policy;
        int x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning1Policy(poolFilter, tieBreaker);
        subpop.individuals[0] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning2Policy(poolFilter, tieBreaker);
        subpop.individuals[1] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning3Policy(poolFilter, tieBreaker);
        subpop.individuals[2] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning4Policy(poolFilter, tieBreaker);
        subpop.individuals[3] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning5Policy(poolFilter, tieBreaker);
        subpop.individuals[4] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);

        // initialise the remaining individuals by BIH
        for (int i = 5; i < subpop.individuals.length; i++) {
            boolean initSuccess = false; // whether the initialisation is successful.

            for(int tries = 0; tries <= subpop.numDuplicateRetries; tries++) {
                x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
                policy = new NearestNeighbourPolicy(poolFilter, tieBreaker);

                GiantTaskSequenceIndividual indi = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);

                // check if the new individual is a duplicate
                boolean isDuplidate = false;
                for (int j = 0; j < i; j++) {
                    if (indi.equals(subpop.individuals[j])) {
                        isDuplidate = true;
                        break;
                    }
                }

                if (!isDuplidate) {
//                    System.out.println(i + ": " + indi.toString());
                    subpop.individuals[i] = indi;
                    initSuccess = true;
                    break;
                }
            }

            if (!initSuccess) {
                subpop.individuals[i] = species.newIndividual(state, thread);
//                System.out.println(i + ":: " + subpop.individuals[i].toString());
            }

        }

        return p;
    }
}
