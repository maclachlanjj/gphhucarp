package gphhucarp.algorithm.sopoc;

import ec.EvolutionState;
import ec.Individual;
import ec.Population;
import ec.Subpopulation;
import ec.gp.GPIndividual;
import ec.gp.GPInitializer;
import ec.multiobjective.MultiObjectiveFitness;
import ec.simple.SimpleInitializer;
import gphhucarp.algorithm.edasls.EDASLSEvolutionState;
import gphhucarp.algorithm.edasls.EDASLSProblem;
import gphhucarp.algorithm.edasls.GiantTaskSequenceIndividual;
import gphhucarp.algorithm.edasls.GiantTaskSequenceSpecies;
import gphhucarp.core.InstanceSamples;
import gphhucarp.decisionprocess.PoolFilter;
import gphhucarp.decisionprocess.RoutingPolicy;
import gphhucarp.decisionprocess.TieBreaker;
import gphhucarp.decisionprocess.poolfilter.ExpFeasiblePoolFilter;
import gphhucarp.decisionprocess.routingpolicy.*;
import gphhucarp.decisionprocess.tiebreaker.RandomTieBreaker;
import gphhucarp.gp.UCARPPrimitiveSet;
import gputils.LispUtils;
import org.apache.commons.math3.random.RandomDataGenerator;

/**
 * The initializer used by SoPoC.
 * For the EDASLS part, the first 5 individuals are generated by Path Scanning.
 * The remaining popsize-5 individuals are generated by Best Insertion Heuristic.
 * No duplication is allowed.
 * For the GP part, the ramp-harf-and-half is used.
 */

public class SoPoCInitializer extends GPInitializer {

    @Override
    public Population initialPopulation(final EvolutionState state, int thread) {
        Population p = setupPopulation(state, thread);

        // initialise a random tie breaker
        SoPoCEvolutionState sopocState = (SoPoCEvolutionState)state;
        RandomDataGenerator rdg = sopocState.getRdg();
        PoolFilter poolFilter = new ExpFeasiblePoolFilter();
        TieBreaker tieBreaker = new RandomTieBreaker(rdg);

        // get the instances
        SoPoCProblem problem = (SoPoCProblem)state.evaluator.p_problem;
        InstanceSamples iSamples = problem.getEvaluationModel().getInstanceSamples().get(0);

        /**
         * Initialise the first sub-population for EDASLS
         */
        Subpopulation subpop = p.subpops[0];
        GiantTaskSequenceSpecies species = (GiantTaskSequenceSpecies)subpop.species;

        // initialise the first 5 individuals by path scanning
        RoutingPolicy policy;
        int x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning1Policy(poolFilter, tieBreaker);
        subpop.individuals[0] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning2Policy(poolFilter, tieBreaker);
        subpop.individuals[1] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning3Policy(poolFilter, tieBreaker);
        subpop.individuals[2] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning4Policy(poolFilter, tieBreaker);
        subpop.individuals[3] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);
        x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
        policy = new PathScanning5Policy(poolFilter, tieBreaker);
        subpop.individuals[4] = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);

        // initialise the remaining individuals by BIH
        for (int i = 5; i < subpop.individuals.length; i++) {
            boolean initSuccess = false; // whether the initialisation is successful.

            for(int tries = 0; tries <= subpop.numDuplicateRetries; tries++) {
                x = rdg.nextInt(0, iSamples.getSeeds().size()-1);
                policy = new NearestNeighbourPolicy(poolFilter, tieBreaker);

                GiantTaskSequenceIndividual indi = species.construct(iSamples.getBaseInstance(), iSamples.getSeed(x), policy);

                // check if the new individual is a duplicate
                boolean isDuplidate = false;
                for (int j = 0; j < i; j++) {
                    if (indi.equals(subpop.individuals[j])) {
                        isDuplidate = true;
                        break;
                    }
                }

                if (!isDuplidate) {
//                    System.out.println(i + ": " + indi.toString());
                    subpop.individuals[i] = indi;
                    initSuccess = true;
                    break;
                }
            }

            if (!initSuccess) {
                subpop.individuals[i] = species.newIndividual(state, thread);
//                System.out.println(i + ":: " + subpop.individuals[i].toString());
            }
        }

        /**
         * Initialise the second sub-population: GP individuals
         */
        p.subpops[1].populate(state, thread);

        // initialise the context vector: the policy is initialised as RQ-DEM
        Individual[] contextVector = new Individual[2];
        GPIndividual policy1 = (GPIndividual)(p.subpops[1].species.newIndividual(state, 0));
        policy1.trees[0] = LispUtils.parseExpression("(- RQ DEM)", UCARPPrimitiveSet.wholePrimitiveSet());
        contextVector[1] = policy1;

        // initialise the context fitness to be infinity (to be minimised)
        MultiObjectiveFitness contextFitness = new MultiObjectiveFitness();
        contextFitness.objectives = new double[problem.getObjectives().size()];
        contextFitness.maxObjective = new double[problem.getObjectives().size()];
        contextFitness.minObjective = new double[problem.getObjectives().size()];
        contextFitness.maximize = new boolean[problem.getObjectives().size()];

        for (int i = 0; i < contextFitness.objectives.length; i++)
            contextFitness.objectives[i] = Double.POSITIVE_INFINITY;

        SoPoCEvolutionState soPoCState = (SoPoCEvolutionState)state;
        soPoCState.setContextVector(contextVector);
        sopocState.setContextFitness(contextFitness);

        return p;
    }
}
